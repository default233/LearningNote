# 所有奇数长度子数组的和
[题目连接](https://leetcode-cn.com/problems/sum-of-all-odd-length-subarrays/)

## 一、题目描述

给你一个正整数数组 arr ，请你计算所有可能的奇数长度子数组的和。

子数组 定义为原数组中的一个连续子序列。

请你返回 arr 中 所有奇数长度子数组的和 。

示例 ：

输入：arr = [1,4,2,5,3]
输出：58
解释：所有奇数长度子数组和它们的和为：
[1] = 1
[4] = 4
[2] = 2
[5] = 5
[3] = 3
[1,4,2] = 7
[4,2,5] = 11
[2,5,3] = 10
[1,4,2,5,3] = 15
我们将所有值求和得到 1 + 4 + 2 + 5 + 3 + 7 + 11 + 10 + 15 = 58

## 二、解法

### 1. 暴力解法

三层循环解决问题。

- 外层循环循环子数组的长度，规定为奇数，依此递增2
- 中层循环循环子数组的起始位置
- 内存循环计算子数组的和，这里我们之间将其加在总和中

```java
public int sumOddLengthSubarrays(int[] arr) {
    int len = arr.length;
    int sum = 0;
    for (int i = 1; i <= len; i=i+2) {
        for (int j = 0; j < len - i + 1; j++) {
            for (int k = j; k < j + i; k++) {
                sum += arr[k];
            }
        }
    }
    return sum;
}
```

运行结果

> 执行用时：4 ms, 在所有 Java 提交中击败了100.00%的用户
>
> 内存消耗：36.6 MB, 在所有 Java 提交中击败了100.00%的用户

时间复杂度：$O(n^3)$

空间复杂度：$O(1)$

### 2. 规律解法

实际上，我们只需要统计每个数字在所有奇数长度子数组中出现的次数。然后将每个数字乘上它出现的次数再求和即可。

所以问题的关键是如何统计每个数字在奇数长度子数组中出现的个数。

我们以数组[1,4,2,5,3]为例

对于数字"4"，为了形成数组，我们可以在其左右两边分别添上若干数

左边可以添加 0、1 个数字

右边可以添加 0、1、2、3 个数字

- 当左边添加奇数个数字时，右边也需要添加奇数个数字，这样加上本身，总长度为奇数
- 当左边添加偶数个数字时，右边也需要添加偶数个数字，总长度也为奇数

下面我们看一般情况：

对于长度为 n 的数组的下标为 i 的数字，我们统计其在长度为奇数的子数组中出现的次数

对于数字arr[i]，其左边可以添加 0、1、2、... 、i 个数字，则共有 i + 1 种选择，这些选择中，

- 奇数个数字的选择有 (i + 1) / 2种
- 偶数个数字的选择有 (i + 1 + 1) / 2 种

其右边可以添加，0、1、2、... 、n - i - 1 个数字，则共有 n - i 种选择，在这些选择中

- 奇数个数字的选择有 (n - i) / 2 种
- 偶数个数字的选择有 (n - i + 1) / 2 种

因此，数字arr[i]在长度为奇数的子数组中出现的次数为 

((i+1)/2)\*((n-i)/2) + ((i+1+1)/2)\*((n-i+1)/2)

具体实现代码如下

```java
public int sumOddLengthSubarrays(int[] arr) {
    int n = arr.length;
    int sum = 0;
    for (int i = 0; i < n; i++) {
        // 出现的次数等于 左边奇数选择 * 右边奇数选择 + 左边偶数选择 * 右边偶数选择
        int times = ((i+1)/2)*((n-i)/2) + ((i+1+1)/2)*((n-i+1)/2);
        sum = sum + arr[i] * times;
    }
    return sum;
}
```

运行结果

> 执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户
>
> 内存消耗：36.7 MB, 在所有 Java 提交中击败了100.00%的用户

时间复杂度：$O(n)$

空间复杂度：$O(1)$